# 理解拷贝语义与移动语义

让我们忘掉 `Clone`，尝试为一个简单的非 `Copy` 类型实现复制：

```rust
struct NonCopy;

let original = NonCopy;
let duplicate = original;

drop(original)
```

最后一行意在证明：在 `original` 赋值 `duplicate` 以后，`original` 仍然在作用域内 —— 很显然，情况并非如此。任何一位拥有良好直觉的 Rust 入门者，都会赶在编译器之前拒绝这份代码：非 `Copy` 类型不能被平凡拷贝，早在 `drop` 调用以前，`original` 就已经因为移动语义失效了。

那么，能不能用裸指针解引用的方式来绕过这一行为呢？

```rust
let original = NonCopy;
let ptr = &raw const original;
let duplicate = unsafe { *ptr };
```

答案是不行，这段代码无法编译。即使是在 `unsafe` 块中，借用检查仍然发挥着作用。想要明确地绕开借用检查，我们可以尝试使用 `ptr::read`：

```rust
let original = NonCopy;
let ptr = &raw const original;
let duplicate = unsafe { std::ptr::read(ptr) };
```

对于任意指针 `*const T`，`ptr::read` 会从指向的位置开始，按位拷贝 `size_of::<T>()` 个字节的内存，无论 `T` 是否实现了 `Copy`。那么，这样做安全吗？

具体到 `NonCopy`，这样做显然是安全的。但是，如果在任何情况下，这种写法都是安全的，那么 `Copy` 就没有存在的必要了：所有类型都可以通过简单地按位拷贝来实现复制，何必区分 `Copy` 和非 `Copy` 呢？为了说明 `ptr::read` 的危险性，考虑下面这段代码：

```rust
let original = String::new();
let ptr = &raw const original;
let duplicate = unsafe { std::ptr::read(ptr) };
```

与 `NonCopy` 不同，`String` 实现了 `Drop`：当 `String` 离开作用域时，它会将堆分配（heap allocation）的起始地址、大小和对齐信息传递给分配器，由分配器释放内存。在上面这段代码中，由于 `duplicate` 是 `original` 的按位拷贝，两者会指向同一块堆内存，也就是说，当它们析构时，堆内存会被释放两次！这种行为被称作**双重释放**（double free），是一种严重的[**未定义行为**]（undefined behavior）。

如果双重释放不够直观，考虑下面的例子：

```rust
use std::rc::Rc;

// 创建共享指针并赋值 `original`， 引用计数初始化为 1
let original = Rc::new(42);
assert_eq!(Rc::strong_count(&original), 1);

{
    // 克隆共享指针并赋值 `duplicate`，引用计数增长为 2
    let duplicate = Rc::clone(&original);
    assert_eq!(Rc::strong_count(&original), 2);

    // 按位拷贝共享指针并赋值 `triplicate`，引用计数保持为 2
    {
        let ptr = &raw const duplicate;
        let triplicate = unsafe { std::ptr::read(ptr) };
        assert_eq!(Rc::strong_count(&original), 2);
    }

    // `triplicate` 离开作用域，引用计数降低为 1
    assert_eq!(Rc::strong_count(&original), 1);
}

// `duplicate` 离开作用域，引用计数降低为 0，释放堆内存
assert_eq!(Rc::strong_count(&original), 0);

// 打印 `original`，输出任意值
println!("{original}");
```

在打印 `original` 时，共享指针指向的是一块已经无效的内存，对这块内存的任何操作都属于**释放后使用**（use after free），这同样是一种严重的未定义行为。运行这段代码可能输出任意值，0 是一种常见情况，但这属于分配器的实现细节，无法得到任何保证。

想要避免这些未定义行为，我们必须保证：对于通过按位拷贝构造的非 `Copy` 类型的多个实例，最多只有一个被析构。例如：

```rust
let original = String::new();
let ptr = &raw const original;
let duplicate = unsafe { std::ptr::read(ptr) };
std::mem::forget(original);
```

等等，一开始的目标不是实现复制吗，如果只「记得」诸多复制品中的一个，那复制又从何谈起呢？没错，我们没有实现复制，我们只是重新发明了移动语义：

```rust
let old = String::new();
let new = old;
```

[**未定义行为**]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
