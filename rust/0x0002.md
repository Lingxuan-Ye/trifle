# 异步函数中的析构

虽然 RAII (Resource Acquisition Is Initialization) 这个名字不可谓不烂，它对那个曾经看到上下文管理器都高呼优雅的我而言，简直就是在闪闪发光。总的来说，我与这一整套逻辑都相处融洽，直到我遇到异步代码：

```rust
use tokio::time::{Duration, sleep};

#[tokio::main]
async fn main() {
    let foo = Foo;
    sleep(Duration::from_millis(1)).await;
    println!("awoken");
}

struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("dropped");
    }
}
```

从语法一致性的要求上看，`foo` 应该在离开函数时析构，即先输出 "awoken"，再输出 "dropped"；然而，对于异步函数而言，不存在一个贯穿整个函数的调用栈，它实际上会返回一个实现了 `Future` 的匿名结构体。该结构体会将跨越了 `await` 的变量作为字段保存，而没有跨越的变量则只出现在 `poll` 的调用栈中。从这个角度上看，上述代码应该先输出 "dropped"，再输出 "awoken" —— 除非 `foo` 跨越了 `sleep(Duration::from_millis(1)).await;`。

实际的运行结果是前者，也就是说，尽管 `foo` 在 `await` 以后没有被使用，它仍然保存在了匿名结构体中。换而言之，所谓的跨越不是指变量在 `await` 以后仍然被使用，而是指作用域包含了 `await` 点。

我在说什么，这好像是件理所应当的事。
