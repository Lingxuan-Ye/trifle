# 异步函数中的析构

虽然 RAII (Resource Acquisition Is Initialization) 的名字不可谓不烂，它对那个曾经看到上下文管理器都高呼优雅的我而言简直就在闪闪发光。总的来说，这一整套逻辑都很符合直觉，直到我遇到异步代码：

```rust
use tokio::time::{Duration, sleep};

#[tokio::main]
async fn main() {
    let foo = Foo;
    sleep(Duration::from_millis(1)).await;
    println!("awoken");
}

struct Foo;

impl Drop for Foo {
    fn drop(&mut self) {
        println!("dropped");
    }
}
```

从语法一致性的要求上看，`foo` 应该在离开函数时析构，即先输出 "awoken"，再输出 "dropped"；然而，对于异步函数而言，不存在一个贯穿整个函数的调用栈，它实际上会返回一个实现了 `Future` 的匿名结构体。该结构体会将跨越了 `await` 的变量作为字段保存，而没有跨越的变量则只出现在 `poll` 的调用栈中。从这个角度上看，上述代码应该先输出 "dropped"，再输出 "awoken" —— 除非 `foo` 跨越了 `sleep(Duration::from_millis(1)).await;`。

实际的运行结果是前者，也就是说，尽管 `foo` 在 `await` 以后没有被使用，它仍然保存在了匿名结构体中。换而言之，所谓的跨越不是指变量在 `await` 以后仍然被使用，而是指作用域包含了 `await` 点。

我在说什么，这好像是件理所应当的事。
