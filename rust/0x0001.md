# 理解拷贝语义与移动语义

让我们忘掉 `Clone`，尝试为一个简单的非 `Copy` 类型实现复制：

```rust
struct NonCopy;

let original = NonCopy;
let duplicate = original;

drop(original)
```

最后一行意在证明：在 `original` 赋值 `duplicate` 以后，`original` 仍然在作用域内 —— 很显然，情况并非如此。任何一位拥有良好直觉的 Rust 入门者，都会赶在编译器之前拒绝这份代码：非 `Copy` 类型不能被平凡拷贝，早在 `drop` 调用以前，`original` 就已经因为移动语义失效了。

那么，能不能用裸指针解引用的方式来绕过这一行为呢？

```rust
let original = NonCopy;
let ptr = &raw const original;
let duplicate = unsafe { *ptr };
```

答案是不行，这段代码无法编译。即使是在 `unsafe` 块中，借用检查仍然发挥着作用。想要明确地绕开借用检查，我们可以尝试使用 `ptr::read`：

```rust
let original = NonCopy;
let ptr = &raw const original;
let duplicate = unsafe { std::ptr::read(ptr) };
```

对于任意指针 `*const T`，`ptr::read` 会从指向的位置开始，按位拷贝 `size_of::<T>()` 个字节的内存，无论 `T` 是否实现了 `Copy`。那么，这样做安全吗？

具体到 `NonCopy`，这样做显然是安全的。但是，如果在任何情况下，这种写法都是安全的，那么 `Copy` 就没有存在的必要了：所有类型都可以通过简单地按位拷贝来实现复制，何必区分 `Copy` 和非 `Copy` 呢？为了说明 `ptr::read` 的危险性，考虑下面这段代码：

```rust
let original = String::from("Hello, world!");
let ptr = &raw const original;
let duplicate = unsafe { std::ptr::read(ptr) };
```

与 `NonCopy` 不同，`String` 实现了 `Drop`：当 `String` 离开作用域时，它会将堆分配（heap allocation）的起始地址、大小和对齐信息传递给分配器，由分配器释放内存。在上面这段代码中，由于 `duplicate` 是 `original` 的按位拷贝，两者会指向同一块堆内存，也就是说，当它们析构时，堆内存会被释放两次！这种行为被称作**双重释放**（double free），是一种严重的[**未定义行为**]（undefined behavior）。

如果双重释放不够直观，考虑下面的例子：

```rust
use std::rc::Rc;

// 创建共享指针并赋值 `original`，引用计数初始化为 1。
let original = Rc::new(42);
assert_eq!(Rc::strong_count(&original), 1);

// 按位拷贝共享指针并赋值 `duplicate`，引用计数保持为 1。
let ptr = &raw const original;
let duplicate = unsafe { std::ptr::read(ptr) };
assert_eq!(Rc::strong_count(&original), 1);

// `duplicate` 离开作用域，引用计数降为 0，释放堆内存。
drop(duplicate);
assert_eq!(Rc::strong_count(&original), 0);

// 打印 `original`，输出任意值。
println!("{original}");
```

在打印 `original` 时，共享指针指向的内存已经无效，对这块内存的任何操作都属于**释放后使用**（use after free），这是另一种严重的未定义行为。运行这段代码可能输出任意值，0 是一种常见输出，但这属于分配器的实现细节，无法得到任何保证。

想要避免这些未定义行为，我们必须保证：对于通过按位拷贝构造的非 `Copy` 类型的多个实例，最多只有一个被析构。例如：

```rust
let original = String::from("Hello, world!");
let ptr = &raw const original;
let duplicate = unsafe { std::ptr::read(ptr) };
std::mem::forget(original);
```

等等，一开始的目标不是实现复制吗，如果只「记得」诸多复制品中的一个，那么复制又从何谈起呢？没错，我们没有实现复制，我们只是重新发明了移动语义。

[**未定义行为**]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html
